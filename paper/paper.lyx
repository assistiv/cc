#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass amsart
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Clone detection that scales
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Section
Clone detection as a map reduce
\end_layout

\begin_layout Subsection
Gathering data
\end_layout

\begin_layout Standard
Before we can explain the inner working of our algorithm, we shall first
 explain where and how we got the data we are going to analyze.
\begin_inset Note Note
status open

\begin_layout Plain Layout
The previous section tries to give structure to the entire thesis.
 That's what the introduction is for.
 Here, just say what this section does.
\end_layout

\end_inset

 The choice went 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
You're talking about choices, as if you're documenting the decision process.
 That isn't the goal.
 Instead, outline why ohloh is a good pick.
 Also: less prosaic.
 More scientific.
 Make sure you read enough related work, if only to get a feeling for the
 usual style.
\end_layout

\end_inset

on Ohloh which is a directory of open source projects amongst other things.
 Statistics about the usage of programming languages is evaluated on every
 registered project.
 We are especially interested in Java source files, as our parser is currently
 only capable to tokenize Java files on function level.
 In order to get these repository URLs we used a website parsing approach.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Every paragraph gets only one topic.
 Read 
\begin_inset Quotes eld
\end_inset

write to the point
\begin_inset Quotes erd
\end_inset

, it's an excellent and very short manual on writing.
 Here, you're discussing both the quality of ohloh, and implementation details
 in one paragraph.
 That cannot be.
\end_layout

\end_inset

 Under the URL http://www.ohloh.net/tags/java 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
URLs should be in a latex url environment.
\end_layout

\end_inset

all projects tagged with 
\begin_inset Quotes eld
\end_inset

java
\begin_inset Quotes erd
\end_inset

 are listed.
 By writing a ruby script we were able to crawl all listed repositories
 of the evaluated projects.
 We exclusively process Git repositories as we only implemented a parser
 for this type of repository.
\end_layout

\begin_layout Standard
After parsing the repository URLs, we had to determine which one of the
 found repository was the official one (example: http://www.ohloh.net/p/php/enlist
ments).
 We came up with a scoring system 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe! Where's the code?
\end_layout

\end_inset

 to 
\begin_inset Note Note
status open

\begin_layout Plain Layout
general blabber
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Address all comments.
 Either answer, or fix and delete.
\end_layout

\end_inset

 evaluate the one repository we were interested in per project.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Indeed, more details.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Git 
\end_layout

\begin_layout Standard
Git enables us to store and retrieve revision controlled data in an efficient
 way.
 This allows us to process the whole project's source code at specific versions.
 In our setup
\begin_inset Note Note
status open

\begin_layout Plain Layout
comma
\end_layout

\end_inset

 we only need to read two Git files to get the data we need.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
There could be several pack files.
 Also, forward reference: 
\begin_inset Quotes eld
\end_inset

the following two kinds of files
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The packed-refs file
\end_layout

\begin_layout Standard
Important versions like releases or release candidates usually get tagged.
 All tags are stored in the packed-refs file.
 In order to gain performance improvements while processing a repository's
 data, we chose to rely on the newest fifteen 
\begin_inset Note Note
status open

\begin_layout Plain Layout
check number
\end_layout

\end_inset

 tags of a project repository.
\end_layout

\begin_layout Subsubsection
The pack file
\end_layout

\begin_layout Standard
This single file contains all versioned data of a project.
 Specific files at a certain version can be fetched with dedicated instructions.
 For this task we use JGit which is an implementation of the Git SCM in
 Java.
 Later in the mapping phase, when we load all the data and fill up the database,
 we dynamically load the contents of the pack file into memory, but never
 on disk.
\end_layout

\begin_layout Subsubsection
Cloning
\end_layout

\begin_layout Standard
For each gathered repository URL we execute the command 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

git clone --bare <repositoryURL>
\end_layout

\end_inset

to copy the repository to a local directory.
 The option 
\shape italic
--bare
\shape default
 prevents Git to extract the files from the latest working copy to disk.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Idea: Why not create a MR task to clone all repos? Mappers directly clone
 into HDFS directory /project-clone-detector/projects/.
 The reducer finally creates the Hadoop Archive file in /projects/projects.har.
 What do you think about that Niko?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
I think it's great :).
 But keep in mind: the current approach is not broken.
 It may be inefficient, but it isn't broken.
 Focus on the most important parts to get a great thesis.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We then pack all downloaded repositories into a Hadoop Archive file in order
 to increase efficiency.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Gee, details!
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cluster setup
\end_layout

\begin_layout Standard
Our cluster setup consists of four server machines: Haddock, Leela, Bender
 and Pinocchio.
 Leela is the strongest machine: [Spec-sheet: 128GB RAM, 32 CORES].
 All the others have 16GB of RAM and 8 Cores each.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Your goal: explain the setup.
 Why like this?
\end_layout

\end_inset

 The most important criterion regarding our MR design was to get as much
 RAM as we could.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hmm.
 The point of leela having so much RAM is to support random read access
 in HBase.
 That's important for the populate phase.
 Should talk about it.
 Can also talk about leela having a lot of cores, which works great with
 M/R.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hadoop
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Not a focus point.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Resource Manager: Haddock
\end_layout

\begin_layout Standard
Namenodes: All 4 with different amount of resources.
\end_layout

\begin_layout Standard
History server: Leela
\end_layout

\begin_layout Standard
Log aggregation enabled.
\end_layout

\begin_layout Standard
HDFS - Our projects are stored inside HDFS.
\end_layout

\begin_layout Subsubsection
HBase
\end_layout

\begin_layout Standard
The HBase master as well as the region server service are installed on Leela.
\end_layout

\begin_layout Subsubsection
Database layout
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this brevity, incomprehensible.
 The point of the layout is to save space.
 It's inspired by how git stores its objects.
\end_layout

\begin_layout Plain Layout
Make example graphs.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Population phase tables
\end_layout

\begin_deeper
\begin_layout Itemize
versions
\end_layout

\begin_layout Itemize
files
\end_layout

\begin_layout Itemize
functions
\end_layout

\begin_layout Itemize
facts
\end_layout

\end_deeper
\begin_layout Itemize
Clone escalation phase tables
\end_layout

\begin_deeper
\begin_layout Itemize
indexFacts2Functions
\end_layout

\begin_layout Itemize
indexFacts2FunctionsStep2
\end_layout

\end_deeper
\begin_layout Itemize
Special tables
\end_layout

\begin_deeper
\begin_layout Itemize
strings
\end_layout

\begin_layout Itemize
hashfactContent
\end_layout

\end_deeper
\begin_layout Subsubsection
Configuration files
\end_layout

\begin_layout Standard
As our cluster consists of heterogeneous nodes, an adjusted configuration
 file can not simply be distributed to the nodes.
 We wrote a ruby script 
\begin_inset Note Note
status open

\begin_layout Plain Layout
insert link to configuration merge script
\end_layout

\end_inset

 to merge node specific configurations with the more general cluster configurati
on.
\begin_inset Note Note
status open

\begin_layout Plain Layout
That's missing in Hadoop.
 Should mention it.
\end_layout

\end_inset

 It expects two customized files in the Hadoop configuration directory 
\shape italic
/etc/hadoop/conf
\shape default
.
 Cluster specific configuration properties are set in the file 
\shape italic
default-config.xml
\shape default
, node specific ones in 
\shape italic
site-config.xml
\shape default
.
 During the merge process, node specific properties always override cluster
 specific ones.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The exact working of the script has yet to be defined.
\end_layout

\end_inset

 The generated file is the 
\shape italic
core-site.xml
\shape default
.
 All other configuration files 
\shape italic
hdfs-site.xml,
\shape default
 
\shape italic
mapred-site.xml
\shape default
 and 
\shape italic
yarn-site.xml
\shape default
 are all symlinks to 
\shape italic
core-site.xml
\shape default
.
\end_layout

\begin_layout Subsection
Launching Map/Reduce Jobs
\end_layout

\begin_layout Standard
To quickly launch map/reduce jobs out of our development environment we
 created Ant targets.
 Essentially 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Sentence ends a bit abrupt.
\end_layout

\end_inset

 
\end_layout

\begin_layout Subsection
Algorithm
\end_layout

\begin_layout Standard
In this section we will demonstrate the complete working of the algorithm
 in detail using an example.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Simon: describe algorithm.
 Beispiel!!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider these two dummy 
\begin_inset Note Note
status open

\begin_layout Plain Layout
s/dummy/simple and similar/
\end_layout

\end_inset

 java files:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Whenever we discuss the algorithm, we make examples on the white board.
 We do that because it's the way to go to understand what's going on.
 Don't give the reader any less.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package ch.unibe.testdata;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Apfel {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

	 * @param args
\end_layout

\begin_layout Plain Layout

	 */
\end_layout

\begin_layout Plain Layout

	public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

		String name = "Apfel";
\end_layout

\begin_layout Plain Layout

		System.out.println(name);
\end_layout

\begin_layout Plain Layout

		int a = 10;
\end_layout

\begin_layout Plain Layout

		while (a > 0) {
\end_layout

\begin_layout Plain Layout

			System.out.println("a" + a);
\end_layout

\begin_layout Plain Layout

			a -= 1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		for (int i = 0; i < 10; i++) {
\end_layout

\begin_layout Plain Layout

			System.out.println("i" + i);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		System.out.println("finished");
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package ch.unibe.testdata;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Birne {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

	 * @param args
\end_layout

\begin_layout Plain Layout

	 */
\end_layout

\begin_layout Plain Layout

	public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

		String name = "Birne";
\end_layout

\begin_layout Plain Layout

		System.out.println(name);
\end_layout

\begin_layout Plain Layout

		int a = 10;
\end_layout

\begin_layout Plain Layout

		while (a > 0) {
\end_layout

\begin_layout Plain Layout

			System.out.println("a" + a);
\end_layout

\begin_layout Plain Layout

			a -= 1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		for (int i = 0; i < 10; i++) {
\end_layout

\begin_layout Plain Layout

			System.out.println("i" + i);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		System.out.println("finished");
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Population phase
\end_layout

\begin_layout Standard
The table population phase is defined in the 
\shape italic
GitTablePopulatorMapper
\shape default
 class.
 Each mapper gets a path to a Git repository as input.
 We then read the packed-refs file and scan all java source files of the
 least 15 
\begin_inset Note Note
status open

\begin_layout Plain Layout
check number
\end_layout

\end_inset

 tags.
 Next we calculate the SHA-1 hash for every file we find and query the table
 
\shape italic
files
\shape default
 to determine whether we already processed the file.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Selling point: No random reading across the cluster.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Table populate: avoid flush, avoid read.
 Quote: Bigtable paper, GFS paper.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
MR Steps - Explain whole procedure using a detailed example - Process HDFS-Folde
r with all pack files - Clone Escalation
\end_layout

\begin_layout Standard
GitTablePopulator: Process HDFS-Folder with all pack files (see section
 Git pack files...).
 GitPackFile RecordReader.
 Before the real Map-job starts, all folders in a specific HDFS-folder are
 scanned.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Is this a comment? Maybe it should go into a lyx comment?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Tracing snippets
\end_layout

\begin_layout Subsection
Distribution of clones
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Empirical Cumulative distribution function would be nice.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Histogram MR-Job, explain results, refer to paper 
\begin_inset Quotes eld
\end_inset

On how often code is cloned across repositories
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Lessons learnt
\end_layout

\begin_layout Subsection
Leap second bug or how we won 1 second and lost a week
\end_layout

\begin_layout Standard
We were not aware of the Leap second which was added at at 23:59:60 UTC
 on June 30, 2012.
 Java processes used excessive amount of CPU.
 This led to very slow reaction times of Hadoop and HBase, restarted services
 multiple times.
 In the end, the only thing that effectively helped was a reboot of the
 machines.
 (see https://bugzilla.mozilla.org/show_bug.cgi?id=769972)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
I had no idea.
 Details!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Performance
\end_layout

\end_body
\end_document
