#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass amsart
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Clone detection that scales
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Section
Clone detection as a map reduce
\end_layout

\begin_layout Subsection
Gathering data
\end_layout

\begin_layout Standard
This section explains where and how we collected the data we have analyzed
 in our study.
\end_layout

\begin_layout Paragraph*
Ohloh
\end_layout

\begin_layout Standard
Ohloh is an online directory of open source projects amongst other things.
 By February 2013 it has nearly 60,000 projects listed.
 As Ohloh itself uses the publicly stored software repository URLs to provide
 statistics and metrics of projects, the general quality of the data should
 be outstanding.
 
\end_layout

\begin_layout Standard
We are especially interested in Java source files, as our parser is currently
 only capable to tokenize Java files on function level.
 In order to get these repository URLs we used a website parsing approach.
 Under the URL 
\begin_inset CommandInset href
LatexCommand href
name "http://www.ohloh.net/tags/java"
target "http://www.ohloh.net/tags/java"

\end_inset

 all projects tagged with 
\begin_inset Quotes eld
\end_inset

java
\begin_inset Quotes erd
\end_inset

 are listed.
 By writing a ruby script we were able to crawl all listed repositories
 of the evaluated projects.
 We exclusively process Git repositories as we only implemented a parser
 for this type of repository.
\end_layout

\begin_layout Standard
After parsing the repository URLs, we had to determine which one of the
 found repository was the official one (example: http://www.ohloh.net/p/php/enlist
ments).
 We came up with a scoring system 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe! Where's the code?
\end_layout

\end_inset

 to 
\begin_inset Note Note
status open

\begin_layout Plain Layout
general blabber
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Address all comments.
 Either answer, or fix and delete.
\end_layout

\end_inset

 evaluate the one repository we were interested in per project.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Indeed, more details.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Git 
\end_layout

\begin_layout Standard
Git enables us to store and retrieve revision controlled data in an efficient
 way.
 This allows us to process the whole project's source code at specific versions.
 In our setup, we only need to read the following two kind of files: The
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:packed-refs-file"

\end_inset

 and the 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:pack-file"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
There could be several pack files.
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
I thought that as soon as you execute a push to the server, all resources
 are first stored in one single pack file (implicit git repack)?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:packed-refs-file"

\end_inset

packed-refs file
\end_layout

\begin_layout Standard
Important versions like releases or release candidates usually get tagged.
 All tags are stored in the packed-refs file.
 In order to gain performance improvements while processing a repository's
 data, we chose to rely on the newest fifteen 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
check number
\end_layout

\end_inset

 tags of a project repository.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:pack-file"

\end_inset

pack file
\end_layout

\begin_layout Standard
This single file contains all versioned data of a project.
 Specific files at a certain version can be fetched with dedicated instructions.
 For this task we use JGit which is an implementation of the Git SCM in
 Java.
 Later in the mapping phase, when we load all the data and fill up the database,
 we dynamically load the contents of the pack file into memory, but never
 on disk.
\end_layout

\begin_layout Subsubsection
Cloning
\end_layout

\begin_layout Standard
For each gathered repository URL we execute the command 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

git clone --bare <repositoryURL>
\end_layout

\end_inset

to copy the repository to a local directory.
 The option 
\shape italic
--bare
\shape default
 prevents Git to extract the files from the latest working copy to disk.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Idea: Why not create a MR task to clone all repos? Mappers directly clone
 into HDFS directory /project-clone-detector/projects/.
 The reducer finally creates the Hadoop Archive file in /projects/projects.har.
 What do you think about that Niko?
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
I think it's great :).
 But keep in mind: the current approach is not broken.
 It may be inefficient, but it isn't broken.
 Focus on the most important parts to get a great thesis.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
OK, let's wait with this.
\end_layout

\end_inset

 We wrote a JRuby script which enables concurrent cloning of repositories
 using multiple threads.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
insert link to script
\end_layout

\end_inset

 
\end_layout

\begin_layout Subsubsection
HDFS
\end_layout

\begin_layout Standard
HDFS (Hadoop Distributed FileSystem)
\end_layout

\begin_layout Standard
To ensure that no unnecessary namespace gets wasted we pack all downloaded
 repositories into a Hadoop Archive.
 file in order to increase efficiency.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Gee, details! TODO
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cluster setup
\end_layout

\begin_layout Standard
Our cluster setup consists of four server machines: Haddock, Leela, Bender
 and Pinocchio.
 Leela is the strongest machine: [Spec-sheet: 128GB RAM, 32 CORES].
 All the others have 16GB of RAM and 8 Cores each.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Your goal: explain the setup.
 Why like this?
\end_layout

\end_inset

 The most important criterion regarding our MR design was to get as much
 RAM as we could.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hmm.
 The point of leela having so much RAM is to support random read access
 in HBase.
 That's important for the populate phase.
 Should talk about it.
 Can also talk about leela having a lot of cores, which works great with
 M/R.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hadoop
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Not a focus point.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Resource Manager: Haddock
\end_layout

\begin_layout Standard
Namenodes: All 4 with different amount of resources.
\end_layout

\begin_layout Standard
History server: Leela
\end_layout

\begin_layout Standard
Log aggregation enabled.
\end_layout

\begin_layout Standard
HDFS - Our projects are stored inside HDFS.
\end_layout

\begin_layout Subsubsection
HBase
\end_layout

\begin_layout Standard
The HBase master as well as the region server service are installed on Leela.
\end_layout

\begin_layout Subsubsection
Database layout
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this brevity, incomprehensible.
 The point of the layout is to save space.
 It's inspired by how git stores its objects.
\end_layout

\begin_layout Plain Layout
Make example graphs.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Population phase tables
\end_layout

\begin_deeper
\begin_layout Itemize
versions
\end_layout

\begin_layout Itemize
files
\end_layout

\begin_layout Itemize
functions
\end_layout

\begin_layout Itemize
facts
\end_layout

\end_deeper
\begin_layout Itemize
Clone escalation phase tables
\end_layout

\begin_deeper
\begin_layout Itemize
indexFacts2Functions
\end_layout

\begin_layout Itemize
indexFacts2FunctionsStep2
\end_layout

\end_deeper
\begin_layout Itemize
Special tables
\end_layout

\begin_deeper
\begin_layout Itemize
strings
\end_layout

\begin_layout Itemize
hashfactContent
\end_layout

\end_deeper
\begin_layout Subsubsection
Configuration files
\end_layout

\begin_layout Standard
As our cluster consists of heterogeneous nodes, an adjusted configuration
 file can not simply be distributed to the nodes.
 We wrote a ruby script 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
insert link to configuration merge script
\end_layout

\end_inset

 to merge node specific configurations with the more general cluster configurati
on.
\begin_inset Note Note
status open

\begin_layout Plain Layout
That's missing in Hadoop.
 Should mention it.
\end_layout

\end_inset

 It expects two customized files in the Hadoop configuration directory 
\shape italic
/etc/hadoop/conf
\shape default
.
 Cluster specific configuration properties are set in the file 
\shape italic
default-config.xml
\shape default
, node specific ones in 
\shape italic
site-config.xml
\shape default
.
 During the merge process, node specific properties always override cluster
 specific ones.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The exact working of the script has yet to be defined.
\end_layout

\end_inset

 The generated file is the 
\shape italic
core-site.xml
\shape default
.
 All other configuration files 
\shape italic
hdfs-site.xml,
\shape default
 
\shape italic
mapred-site.xml
\shape default
 and 
\shape italic
yarn-site.xml
\shape default
 are all symlinks to 
\shape italic
core-site.xml
\shape default
.
\end_layout

\begin_layout Subsection
Launching Map/Reduce Jobs
\end_layout

\begin_layout Standard
To quickly launch map/reduce jobs out of our development environment we
 created Ant targets.
 Essentially 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Sentence ends a bit abrupt.
\end_layout

\end_inset

 
\end_layout

\begin_layout Subsection
Algorithm
\end_layout

\begin_layout Standard
In this section we will demonstrate the complete working of the algorithm
 in detail using an example.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Simon: describe algorithm.
 Beispiel!!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider these two dummy 
\begin_inset Note Note
status open

\begin_layout Plain Layout
s/dummy/simple and similar/
\end_layout

\end_inset

 java files:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Whenever we discuss the algorithm, we make examples on the white board.
 We do that because it's the way to go to understand what's going on.
 Don't give the reader any less.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package ch.unibe.testdata;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Apple {
\end_layout

\begin_layout Plain Layout

	public static void print() {
\end_layout

\begin_layout Plain Layout

		String name = "Apple";
\end_layout

\begin_layout Plain Layout

		System.out.println("Hi from " + name);
\end_layout

\begin_layout Plain Layout

		int a = 10;
\end_layout

\begin_layout Plain Layout

		while (a > 0) {
\end_layout

\begin_layout Plain Layout

			System.out.println("a" + a);
\end_layout

\begin_layout Plain Layout

			a -= 1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		for (int i = 0; i < 10; i++) {
\end_layout

\begin_layout Plain Layout

			System.out.println("i" + i);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		System.out.println("finished");
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package ch.unibe.testdata;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Pear {
\end_layout

\begin_layout Plain Layout

	public static void print() {
\end_layout

\begin_layout Plain Layout

		String name = "Pear";
\end_layout

\begin_layout Plain Layout

		System.out.println("Hi from " + name);
\end_layout

\begin_layout Plain Layout

		int a = 10;
\end_layout

\begin_layout Plain Layout

		while (a > 0) {
\end_layout

\begin_layout Plain Layout

			System.out.println("a" + a);
\end_layout

\begin_layout Plain Layout

			a -= 1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		for (int i = 0; i < 10; i++) {
\end_layout

\begin_layout Plain Layout

			System.out.println("i" + i);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		System.out.println("finished");
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Population phase
\end_layout

\begin_layout Standard
The table population phase is defined in the 
\shape italic
GitTablePopulatorMapper
\shape default
 class.
 Each mapper gets a path to a Git repository as input.
 The mapper then reads the packed-refs file and scans all java source files
 of the latest 15 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
check number
\end_layout

\end_inset

 tags.
 For every found java source file, its SHA-1 hash is being calculated.
 We then check if the file hash already appears in the table 
\shape italic
files
\shape default
 to determine whether we have already processed the file.
 Is this the case we skip the processing of the file contents.
\end_layout

\begin_layout Paragraph*
Processing file content
\end_layout

\begin_layout Standard
We extract all functions out of the file using a regular expression.
 If a function doesn't meet the minimum number of lines (which we set to
 10 lines per default) it gets vanished.
 All functions left over get further handled.
 They are split up in parts of 10 lines using the shingle algorithm.
 For every part we then calculate its hash which leads us to the so called
 hashfact.
\end_layout

\begin_layout Paragraph*
Processing file path
\end_layout

\begin_layout Standard
In the next step the table 
\shape italic
files
\shape default
 gets a new entry with the filepath-hash and the file-hash get stored together
 with the version-hash.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Paragraph*
Processing version tag
\end_layout

\begin_layout Standard
In the table 
\shape italic
versions
\shape default
 the version-hash and the tag get stored together with the project-hash.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Selling point: No random reading across the cluster.
\end_layout

\begin_layout Plain Layout
Table populate: avoid flush, avoid read.
 Quote: Bigtable paper, GFS paper.
\end_layout

\begin_layout Plain Layout
MR Steps - Explain whole procedure using a detailed example - Process HDFS-Folde
r with all pack files - Clone Escalation
\end_layout

\begin_layout Plain Layout
GitTablePopulator: Process HDFS-Folder with all pack files (see section
 Git pack files...).
 GitPackFile RecordReader.
 Before the real Map-job starts, all folders in a specific HDFS-folder are
 scanned.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Tracing snippets
\end_layout

\begin_layout Subsection
Distribution of clones
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Empirical Cumulative distribution function would be nice.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Histogram MR-Job, explain results, refer to paper 
\begin_inset Quotes eld
\end_inset

On how often code is cloned across repositories
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Lessons learnt
\end_layout

\begin_layout Subsection
Leap second bug or how we won 1 second and lost a week
\end_layout

\begin_layout Standard
We were not aware of the Leap second which was added at at 23:59:60 UTC
 on June 30, 2012.
 Java processes used excessive amount of CPU.
 This led to very slow reaction times of Hadoop and HBase, restarted services
 multiple times.
 In the end, the only thing that effectively helped was a reboot of the
 machines.
 (see https://bugzilla.mozilla.org/show_bug.cgi?id=769972)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
I had no idea.
 Details!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Performance
\end_layout

\end_body
\end_document
