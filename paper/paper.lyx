#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass amsart
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
theorems-ams-extended
theorems-sec
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Clone detection that scales
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Section
Clone detection as a map reduce
\end_layout

\begin_layout Subsection
Gathering data
\end_layout

\begin_layout Standard
This section explains where and how we collected the data we have analyzed
 in our study.
\end_layout

\begin_layout Paragraph*
Ohloh
\end_layout

\begin_layout Standard
Ohloh is an online directory of open source projects amongst other things.
 By February 2013 it has nearly 60,000 projects listed.
 As Ohloh itself uses the publicly stored software repository URLs to provide
 statistics and metrics of projects, the general quality of the data should
 be outstanding.
 
\end_layout

\begin_layout Standard
We are especially interested in Java source files, as our parser is currently
 only capable to tokenize Java files on function level.
 In order to get these repository URLs we used a website parsing approach.
 Under the URL 
\begin_inset CommandInset href
LatexCommand href
name "http://www.ohloh.net/tags/java"
target "http://www.ohloh.net/tags/java"

\end_inset

 all projects tagged with 
\begin_inset Quotes eld
\end_inset

java
\begin_inset Quotes erd
\end_inset

 are listed.
 By writing a ruby script we were able to crawl all listed repositories
 of the evaluated projects.
 We exclusively process Git repositories as we only implemented a parser
 for this type of repository.
\end_layout

\begin_layout Standard
After parsing the repository URLs, we had to
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Don't talk this way.
 
\begin_inset Quotes eld
\end_inset

Then, we had to.
\begin_inset Quotes erd
\end_inset

 is no good.
 What did you do? The story of your thesis is not the story of writing it.
\end_layout

\end_inset

 determine which one of the found repository was the official one (example:
 http://www.ohloh.net/p/php/enlistments).
 We came up with a scoring system 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe! Where's the code?
\end_layout

\end_inset

 to 
\begin_inset Note Note
status open

\begin_layout Plain Layout
general blabber
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Address all comments.
 Either answer, or fix and delete.
\end_layout

\end_inset

 evaluate the one repository we were interested in per project.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Indeed, more details.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Git 
\end_layout

\begin_layout Standard
Git enables us to store and retrieve revision controlled data in an efficient
 way.
 This allows us to process the whole project's source code at specific versions.
 In our setup, we only need to read the following two kind of files: The
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:packed-refs-file"

\end_inset

 and the 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:pack-file"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
There could be several pack files.
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
I thought that as soon as you execute a push to the server, all resources
 are first stored in one single pack file (implicit git repack)?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:packed-refs-file"

\end_inset

packed-refs file
\end_layout

\begin_layout Standard
Important versions like releases or release candidates usually get tagged.
 All tags are stored in the packed-refs file.
 In order to gain performance improvements while processing a repository's
 data, we chose to rely on the newest fifteen 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
check number
\end_layout

\end_inset

 tags of a project repository.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:pack-file"

\end_inset

pack file
\end_layout

\begin_layout Standard
This single file contains all versioned data of a project.
 Specific files at a certain version can be fetched with dedicated instructions.
 For this task we use JGit which is an implementation of the Git SCM in
 Java.
 Later in the mapping phase, when we load all the data and fill up the database,
 we dynamically load the contents of the pack file into memory, but never
 on disk.
\end_layout

\begin_layout Subsubsection
Cloning
\end_layout

\begin_layout Standard
For each gathered repository URL we execute the command 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

git clone --bare <repositoryURL>
\end_layout

\end_inset

to copy the repository to a local directory.
 The option 
\shape italic
--bare
\shape default
 prevents Git to extract the files from the latest working copy to disk.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Idea: Why not create a MR task to clone all repos? Mappers directly clone
 into HDFS directory /project-clone-detector/projects/.
 The reducer finally creates the Hadoop Archive file in /projects/projects.har.
 What do you think about that Niko?
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
I think it's great :).
 But keep in mind: the current approach is not broken.
 It may be inefficient, but it isn't broken.
 Focus on the most important parts to get a great thesis.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
OK, let's wait with this.
\end_layout

\end_inset

 We wrote a JRuby script which enables concurrent cloning of repositories
 using multiple threads.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
insert link to script
\end_layout

\end_inset

 
\end_layout

\begin_layout Subsubsection
HDFS
\end_layout

\begin_layout Standard
HDFS (Hadoop Distributed FileSystem)
\end_layout

\begin_layout Standard
To ensure that no unnecessary namespace gets wasted we pack all downloaded
 repositories into a Hadoop Archive.
 file in order to increase efficiency.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Gee, details! TODO
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cluster setup
\end_layout

\begin_layout Standard
Our cluster setup consists of four server machines: Haddock, Leela, Bender
 and Pinocchio.
 Leela is the strongest machine: [Spec-sheet: 128GB RAM, 32 CORES].
 All the others have 16GB of RAM and 8 Cores each.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Your goal: explain the setup.
 Why like this?
\end_layout

\end_inset

 The most important criterion regarding our MR design was to get as much
 RAM as we could.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hmm.
 The point of leela having so much RAM is to support random read access
 in HBase.
 That's important for the populate phase.
 Should talk about it.
 Can also talk about leela having a lot of cores, which works great with
 M/R.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hadoop
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Not a focus point.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Resource Manager: Haddock
\end_layout

\begin_layout Standard
Namenodes: All 4 with different amount of resources.
\end_layout

\begin_layout Standard
History server: Leela
\end_layout

\begin_layout Standard
Log aggregation enabled.
\end_layout

\begin_layout Standard
HDFS - Our projects are stored inside HDFS.
\end_layout

\begin_layout Subsubsection
HBase
\end_layout

\begin_layout Standard
The HBase master as well as the region server service are installed on Leela.
\end_layout

\begin_layout Subsubsection
Database layout
\end_layout

\begin_layout Standard
The database layout is designed to save space and is inspired by how Git
 stores its objects.
\end_layout

\begin_layout Standard
facts -> functions -> files -> versions -> projects
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename hbasetable.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
How does the figure connect? Also, put figures and tables into floats (
\begin_inset Quotes eld
\end_inset

Gleitobjekt
\begin_inset Quotes erd
\end_inset

 in German lyx).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
HBase's strength is how it handles huge dataset entries in a fast and efficient
 way.
 Information stored in columns is always referenced by the row-key.
 One row key can contains references to 0..n columns.
\end_layout

\begin_layout Standard
In the following figures where we show HBase tables, we show them as output
 as we would get when executing the HBase shell.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this brevity, incomprehensible.
 The point of the layout is to save space.
 It's inspired by how git stores its objects.
\end_layout

\begin_layout Plain Layout
Make example graphs.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Population phase tables
\end_layout

\begin_deeper
\begin_layout Itemize
versions
\end_layout

\begin_layout Itemize
files
\end_layout

\begin_layout Itemize
functions
\end_layout

\begin_layout Itemize
facts
\end_layout

\end_deeper
\begin_layout Itemize
Clone escalation phase tables
\end_layout

\begin_deeper
\begin_layout Itemize
indexFacts2Functions
\end_layout

\begin_layout Itemize
indexFacts2FunctionsStep2
\end_layout

\end_deeper
\begin_layout Itemize
Special tables
\end_layout

\begin_deeper
\begin_layout Itemize
strings
\end_layout

\begin_layout Itemize
hashfactContent
\end_layout

\end_deeper
\begin_layout Subsubsection
Configuration files
\end_layout

\begin_layout Standard
As our cluster consists of heterogeneous nodes, an adjusted configuration
 file can not simply be distributed to the nodes.
 We wrote a ruby script 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
insert link to configuration merge script
\end_layout

\end_inset

 to merge node specific configurations with the more general cluster configurati
on.
\begin_inset Note Note
status open

\begin_layout Plain Layout
That's missing in Hadoop.
 Should mention it.
\end_layout

\end_inset

 It expects two customized files in the Hadoop configuration directory 
\shape italic
/etc/hadoop/conf
\shape default
.
 Cluster specific configuration properties are set in the file 
\shape italic
default-config.xml
\shape default
, node specific ones in 
\shape italic
site-config.xml
\shape default
.
 During the merge process, node specific properties always override cluster
 specific ones.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The exact working of the script has yet to be defined.
\end_layout

\end_inset

 The generated file is the 
\shape italic
core-site.xml
\shape default
.
 All other configuration files 
\shape italic
hdfs-site.xml,
\shape default
 
\shape italic
mapred-site.xml
\shape default
 and 
\shape italic
yarn-site.xml
\shape default
 are all symlinks to 
\shape italic
core-site.xml
\shape default
.
\end_layout

\begin_layout Subsection
Launching Map/Reduce Jobs
\end_layout

\begin_layout Standard
To quickly launch map/reduce jobs out of our development environment we
 created Ant targets.
 The targets create a build of the current project and export it to a JAR
 file.
 This JAR file then gets uploaded to a specific node the cluster.
 After the upload is completed the MR-job gets started by a commandline
 call.
 The alterable part is the 
\shape italic
classArgument
\shape default
 which equals the desired MR-job we want to execute.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

hadoop jar ${jarFile} ${libjars} ${classArgument}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Algorithm
\end_layout

\begin_layout Standard
In this section we will demonstrate the complete working of the algorithm
 in detail using an example.
\end_layout

\begin_layout Subsubsection
Job Setup
\end_layout

\begin_layout Standard
Before the GitTablePopulator job starts we have to define the job properties.
 Our design expects that the 
\shape italic
mapreduce.input.fileinputformat.inputdir
\shape default
 property is set with the paths to the currently available Git pack files
 in the given HAR file.
 So we recursively search for these pack files and set the property accordingly.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Niko: Too abstract to be understandable.
 What is searched? By who? How? 
\end_layout

\end_inset

Our example HAR file contains two repositories.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename har.pdf
	height 4cm

\end_inset


\end_layout

\begin_layout Standard
Each repository contains one java source file:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename sourcefiles.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Subsubsection
Population phase
\end_layout

\begin_layout Standard
The table population phase is defined in the 
\shape italic
GitTablePopulatorMapper
\shape default
 class.
 Each mapper gets a path to a bare Git repository as input.
 We use JGit
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Nice footnote :)
\end_layout

\end_inset

JGit is a Java library implementing the Git version control system, see
 
\begin_inset CommandInset href
LatexCommand href
target "http://eclipse.org/jgit/"

\end_inset


\end_layout

\end_inset

 to operate on them.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Show that packed files are far more efficient: Pack file Daten entpacken
 und Grösse summieren/analysieren und Vergleichen mit Pack-File Grösse.
\end_layout

\end_inset

 The mapper then reads the packed-refs file and collects all tags.
 For the latest 15 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
check number
\end_layout

\end_inset

 tags, all scanned java source files are getting processed.
 In our example the packed-refs file for the Apple repository looks like
 this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# pack-refs with: peeled
\end_layout

\begin_layout Plain Layout

1f8d1c6b1d8d52f295005708727aff3cb2afd83a refs/heads/master
\end_layout

\begin_layout Plain Layout

bf2e04ae5fbe9100f5bac1f432a38f0c3113a3a5 refs/tags/v0.1
\end_layout

\begin_layout Plain Layout

^388fabd1e8244c05e3ccdfb4bf3aefc8bbfe9326
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example there is one single tag, namely v0.1, stored.
 This means we are going to browse through the whole source at the specific
 project state linked by the hash bf2e04ae5fbe9100f5bac1f432a38f0c3113a3a5.
\end_layout

\begin_layout Standard
For every found java source file, its SHA-1 hash is being calculated.
 We then check if the file hash already appears in the table 
\shape italic
files
\shape default
 to determine whether we have already processed the file.
 Is this the case we skip the «processing of the file contents» part.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename sourcefileshashes.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Paragraph*
Processing file content
\end_layout

\begin_layout Standard
We extract all functions out of the file using a regular expression.
 If a function doesn't meet the minimum number of lines (which we set to
 10 lines per default) it gets vanished.
 All functions left over get further processed.
 They are split up in shingles, of which each is 10 (the minimum number
 of lines) lines long.
 Now we calculate the hash for every shingle.
 This hash together with the attributes «line-offset» and «number of lines»
 represents the so called 
\series bold
hashfact
\series default
.
\end_layout

\begin_layout Standard
Clone detection is done on three different types of hashes.
 In the following we show how the three different types of clones are created
 
\begin_inset CommandInset citation
LatexCommand cite
key "Schwarz:2012ta"

\end_inset

.
\end_layout

\begin_layout Standard
Type 1 hashes working definition: Two hashfacts are type-1 clones iff they
 differ in nothing but white-space.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename regextype1.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
These hashfacts are now inserted in the facts table:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tablefactstype1.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
Type 2 hashes working definition: Two hashfacts are type-2 clones iff they
 are type-1 clones after every sequence of alphabetical letters is replaced
 by the letter “t”, and all sequences of digits are replaced with the number
 “1”.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename regextype2.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
These hashfacts are now inserted in the facts table:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tablefactstype2.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
Type 3 hashes working definition: Two documents are type-3 clones if and
 only if they share the same sketch.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename regextype3.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
These hashfacts are now inserted in the facts table:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tablefactstype3.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
We notice that this table has only four rows.
 This is because the shinglehasher returns the same value for the shingles
 starting at line 1 and 2.
\end_layout

\begin_layout Standard
So what we have now: we do know the function and all of its hashfacts.
 We assume that a hashfact occurs not more than once in a function 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
TODO: Wie oft wird diese Annahme verletzt?
\end_layout

\end_inset

.
 We do also know the file and all its functions.
 This information now gets stored, the complete facts table looks like follows.
 For the ease of readability we neglect the lexicographic ordering by the
 row key (function).
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tablefactsall.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
The two functions (one of class Apple, one of class Pear) result in three
 different hashes.
 As the type-1 normalized function is different for the two classes, the
 hasher generates two different hashes whereas the type-2 and type-3 normalized
 functions equal in both classes and therefore produce the same hash.
 The functions table now looks as follows.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tablefunctions.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Paragraph*
Processing file path
\end_layout

\begin_layout Standard
In the next step the table 
\shape italic
files
\shape default
 gets a new entry with the filepath-hash and the file-hash get stored together
 with the version-hash.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tablefiles.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Paragraph*
Processing version tag
\end_layout

\begin_layout Standard
In the table 
\shape italic
versions
\shape default
 the version-hash and the tag get stored together with the project-hash.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tableversions.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Paragraph*
Strings
\end_layout

\begin_layout Standard
In the table 
\shape italic
strings
\shape default
 we store the human readable values of data we may need later.
 Currently this applies to the attributes 
\shape italic
filepath (fp)
\shape default
, 
\shape italic
filename (fn)
\shape default
, 
\shape italic
function_snippet (fs)
\shape default
, 
\shape italic
hashfact_snippet (sn)
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tablestrings.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Selling point: No random reading across the cluster.
\end_layout

\begin_layout Plain Layout
Table populate: avoid flush, avoid read.
 Quote: Bigtable paper, GFS paper.
\end_layout

\begin_layout Plain Layout
MR Steps - Explain whole procedure using a detailed example - Process HDFS-Folde
r with all pack files - Clone Escalation
\end_layout

\begin_layout Plain Layout
GitTablePopulator: Process HDFS-Folder with all pack files (see section
 Git pack files...).
 GitPackFile RecordReader.
 Before the real Map-job starts, all folders in a specific HDFS-folder are
 scanned.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cloned functions
\end_layout

\begin_layout Standard
To identify cloned functions over various files and projects we need to
 inverse the mapping of the tables used in the population phase.
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
facts -> functions -> files -> versions
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cloned hashfacts
\end_layout

\begin_layout Subsubsection
Index generation step 1
\end_layout

\begin_layout Standard
In the first index generation phase we invert the mapping functions -> facts.
 As input for the mapper we get all entries of the facts table (see figure
 tablefactsall.pdf 
\begin_inset Note Note
status open

\begin_layout Plain Layout
how do i reference a figure in lyx?
\end_layout

\end_inset

).
 We write the facthashes to the output key and the corresponding functions
 to the output values.
 This gives us the following intermediate data collection:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename indexfacts2functionsmapoutput.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
In the reduce function we omit all hashfacts which only appear in one single
 function.
 All other hashfacts get stored in the table indexFacts2Functions.
 This table now looks like this:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename indexfacts2functionsreduceoutput.pdf
	width 8cm

\end_inset


\end_layout

\begin_layout Subsubsection
Index generation step 2
\end_layout

\begin_layout Subsubsection
Clone escalation
\end_layout

\begin_layout Section
Tracing snippets
\end_layout

\begin_layout Subsection
Distribution of clones
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Empirical Cumulative distribution function would be nice.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Histogram MR-Job, explain results, refer to paper 
\begin_inset Quotes eld
\end_inset

On how often code is cloned across repositories
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Lessons learnt
\end_layout

\begin_layout Subsection
Leap second bug or how we won 1 second and lost a week
\end_layout

\begin_layout Standard
We were not aware of the Leap second which was added at at 23:59:60 UTC
 on June 30, 2012.
 Java processes used excessive amount of CPU.
 This led to very slow reaction times of Hadoop and HBase, restarted services
 multiple times.
 In the end, the only thing that effectively helped was a reboot of the
 machines.
 (see https://bugzilla.mozilla.org/show_bug.cgi?id=769972)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
I had no idea.
 Details!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Performance
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bib"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
